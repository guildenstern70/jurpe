package net.littlelite.utils;

/**
 *
 * Alessio Saltarin General Library Utils
 * package name.alessiosaltarin.utils
 * Copyright Alessio Saltarin 2001,2002,2003
 *
 */

import java.io.File;
import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

/**
 * This class provides basic operations with XML files using DOM.
 */
public class DOMUtils
{

	/**
	 * Provides a representation of XML to stdout.
	 * 
	 * @param node
	 *            It can be a document, an element, an entity, CDATA, text.
	 */
	public static void printNode(Node node)
	{
		int type = node.getNodeType();
		switch (type)
		{
			// print the document element
			case Node.DOCUMENT_NODE:
			{
				System.out.println("<?xml version=\"1.0\" ?>");
				printNode(((Document) node).getDocumentElement());
				break;
			}

				// print element with attributes
			case Node.ELEMENT_NODE:
			{
				System.out.print("<");
				System.out.print(node.getNodeName());
				NamedNodeMap attrs = node.getAttributes();
				for (int i = 0; i < attrs.getLength(); i++)
				{
					Node attr = attrs.item(i);
					System.out.print(" " + attr.getNodeName().trim() + "=\"" + attr.getNodeValue().trim() + "\"");
				}
				System.out.println(">");
				NodeList children = node.getChildNodes();
				if (children != null)
				{
					for (int i = 0; i < children.getLength(); i++)
					{
						printNode(children.item(i));
					}

				}
				break;
			}

				// handle entity reference nodes
			case Node.ENTITY_REFERENCE_NODE:
			{
				System.out.print("&");
				System.out.print(node.getNodeName().trim());
				System.out.print(";");
				break;
			}

				// print cdata sections
			case Node.CDATA_SECTION_NODE:
			{
				System.out.print("");
				break;
			}

				// print text
			case Node.TEXT_NODE:
			{
				System.out.print(node.getNodeValue().trim());
				break;
			}

				// print processing instruction
			case Node.PROCESSING_INSTRUCTION_NODE:
			{
				System.out.print("");
				break;
			}

		}

		if (type == Node.ELEMENT_NODE)
		{
			System.out.println();
			System.out.print("");
		}
	}

	/**
	 * Parse the XML file and create Document
	 * 
	 * @param xmlfile
	 *            Path to XML file
	 * @param namespaceAware
	 *            The parser must parse namespaces too
	 * @return Document XML DOM Document
	 * @see org.w3c.dom.Document
	 */
	public static Document parse(File xmlfile, boolean namespaceAware)
	{
		Document document = null;
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

		// To get a validating parser
		factory.setValidating(false);
		// To get one that understands namespaces
		factory.setNamespaceAware(namespaceAware);

		try
		{
			// Get DocumentBuilder
			DocumentBuilder builder = factory.newDocumentBuilder();
			// Parse and load into memory the Document
			document = builder.parse(xmlfile);
			return document;

		}
		catch (SAXParseException spe)
		{
			// Error generated by the parser
			System.err.println("\n** Parsing error , line " + spe.getLineNumber() + ", uri " + spe.getSystemId());
			System.err.println(" " + spe.getMessage());
			// Use the contained exception, if any
			Exception x = spe;
			if (spe.getException() != null)
			{
				x = spe.getException();
			}
			x.printStackTrace();
		}
		catch (SAXException sxe)
		{
			// Error generated during parsing
			Exception x = sxe;
			if (sxe.getException() != null)
			{
				x = sxe.getException();
			}
			x.printStackTrace();
		}
		catch (ParserConfigurationException pce)
		{
			// Parser with specified options can't be built
			pce.printStackTrace();
		}
		catch (IOException ioe)
		{
			// I/O error
			ioe.printStackTrace();
		}

		return null;

	}

	/**
	 * Parse the XML file and create Document
	 * 
	 * @param xmlfile
	 *            XML file to parse
	 * @return Document Parsed document
	 */
	public static Document parse(File xmlfile)
	{
		return DOMUtils.parse(xmlfile, false);
	}

	/**
	 * This method writes a DOM document to a file
	 * 
	 * @param filename
	 * @param document
	 */
	public static void writeDomToFile(String filename, Document document)
	{
		try
		{
			// Prepare the DOM document for writing
			Source source = new DOMSource(document);

			// Prepare the output file
			File file = new File(filename);
			Result result = new StreamResult(file);

			// Write the DOM document to the file
			// Get Transformer
			Transformer xformer = TransformerFactory.newInstance().newTransformer();
			// Write to a file
			xformer.transform(source, result);
		}
		catch (TransformerConfigurationException e)
		{
			System.out.println("TransformerConfigurationException: " + e);
		}
		catch (TransformerException e)
		{
			System.out.println("TransformerException: " + e);
		}
	}

	/**
	 * Count Elements in Document by Tag Name
	 * 
	 * @param tag
	 * @param document
	 * @return number elements by Tag Name
	 */
	public static int countByTagName(String tag, Document document)
	{
		NodeList list = document.getElementsByTagName(tag);
		return list.getLength();
	}

}